import argparse
import dateutil.parser
import datetime
import requests
import reverse_geocoder as rg
import re
import sys
import time
import util

args = None

# Regular expression to match a coordinate point in the timeline.
# The latitude and longitude are each expressed as a decimal floating point
# number.
rePoint = re.compile('geo:(-?\d*\.\d*),(-?\d*\.\d*)')

def main():
  # Parse command line arguments and read input files.
  parse_args()
  raw = util.read_json_file(args.raw)
  annotated = util.read_json_file(args.annotated, default=[])
  cache_files = []
  for cache_file in args.use_cache:
    ann = util.read_json_file(cache_file)
    cache_files.append(ann)

  # The raw timeline data is a JSON file that is generated by Google, and they
  # may decide to change its format.  This and the other scripts make certain
  # assumptions about the format of the raw data, so check to make sure those
  # assumptions are true.
  validate_raw(raw)

  # The raw timeline data is a list of different types of records.  We only
  # care about the records that have "timelinePath".  Extract these records
  # into a new list.
  raw_timeline = extract_timeline(raw)

  # Compare the previously annotated records with the raw records to make
  # sure they didn't change.  Raise an error and quit if the validation fails.
  validate_annotated_against_raw(raw_timeline, annotated)

  # Reverse geocoding the coordinates can be expensive, so we want to avoid
  # duplicate geocode operations.  Create a cache of the existing annotated
  # data that maps each coordinate to its state.  We can use this cache later
  # in case a new raw record happens to have the same coordinates as one we
  # have already reverse geocoded.
  cache = {}
  add_annotated_to_cache(annotated, cache)
  for ann in cache_files:
    add_annotated_to_cache(ann, cache)

  # Create annotated records for the new raw records, then write out the
  # annotated data.
  annotated = annotate(raw_timeline, annotated, cache)
  util.write_json_file(annotated, args.annotated)


def parse_args():
  """Parse the command line arguments into global "args"."""
  global args
  parser = argparse.ArgumentParser(
      description='Create or update annotated geolocation file from Google '
        'timeline.')
  parser.add_argument('-r', '--raw', required=True,
      help='Raw Google timeline input JSON file.')
  parser.add_argument('-a', '--annotated', required=True,
      help='Annotated output JSON file.')
  parser.add_argument('--geocoder', choices=['local', 'osm'],
      help='Reverse geocoding service to use, only if annotated file does '
        'not yet exist.')
  parser.add_argument('--email',
      help='Your email address. Required when using "osm" geocoder.')
  parser.add_argument('--limit', type=int,
      help='Limit reverse geocoding to to this many requests.')
  parser.add_argument('--use-cache', action='append',
      help='Input annotated file to use as geocode cache (may be repeated)')
  args = parser.parse_args()


def validate_raw(raw):
  """
  Validate our assumptions about the format of the raw timeline data.  Raise
  an error and exit if any of the checks fail.
  """
  if not isinstance(raw, list):
    print(f'ERROR: Raw timeline not a list.')
    sys.exit(1)

  lastEndTime = None
  for rec in raw:
    if not isinstance(rec, dict):
      print(f'ERROR: Raw timeline record not a dictionary.')
      sys.exit(1)

    if 'startTime' not in rec or 'endTime' not in rec:
      print(f'ERROR: Raw timeline record missing start or end time.')
      sys.exit(1)

    try :
      start = dateutil.parser.isoparse(rec['startTime'])
      end = dateutil.parser.isoparse(rec['endTime'])
    except Exception:
      print(f'ERROR: Start or end time has unexpected format:')
      print(f'       Start: {rec["startTime"]}')
      print(f'       End:   {rec["endTime"]}')
      sys.exit(1)

    # The start and end times must be "aware" (containing timezone
    # information), not "naive" (without timezone information).
    if start.tzinfo == None or end.tzinfo == None or \
       start.tzinfo.utcoffset(start) == None or \
       end.tzinfo.utcoffset(end) == None:
      print(f'ERROR: Start or end time is naive (missing timzone):')
      print(f'       Start: {rec["startTime"]}')
      print(f'       End:   {rec["endTime"]}')
      sys.exit(1)

    if start >= end:
      print(f'ERROR: Start time not less than end time:')
      print(f'       Start: {rec["startTime"]}')
      print(f'       End:   {rec["endTime"]}')
      sys.exit(1)

    if 'timelinePath' in rec:
      # The "timelinePath" records must be sorted in time and must not
      # overlap with any other "timelinePath" record.  Note that the
      # non-timelinePath records *do* overlap and are not sorted, but
      # the scripts don't care about this.
      if lastEndTime and start < lastEndTime:
        print(f'ERROR: Start time less than last end time:')
        print(f'       Start: {rec["startTime"]}')
        sys.exit(1)
      lastEndTime = end

      tlPath = rec['timelinePath']
      if not isinstance(tlPath, list):
        print(f'ERROR: Timeline path not a list:')
        print(f'       Start: {rec["startTime"]}')
        sys.exit(1)

      for tlrec in tlPath:
        if not isinstance(tlrec, dict):
          print(f'ERROR: Timeline path record not a dictionary:')
          print(f'       Start: {rec["startTime"]}')
          sys.exit(1)

        try:
          offset = int(tlrec['durationMinutesOffsetFromStartTime'])
        except Exception:
          print(f'ERROR: Timeline path record missing offset or not an int:')
          print(f'       Start: {rec["startTime"]}')

        # Each record in the timeline path contains an offset (in minutes) from
        # the start time.  This offset must be within the [start, end] range.
        #
        # Note that the range includes both start and end.  As a result, a
        # point at the very end of one range and a point as the very beginning
        # of the next range have the same timestamp.
        pointTime = start + datetime.timedelta(minutes=offset)
        if pointTime > end:
          print(f'ERROR: Timeline point time after end time:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {tlrec["durationMinutesOffsetFromStartTime"]}')
          sys.exit(1)

        if 'point' not in tlrec:
          print(f'ERROR: Timeline path record missing coordinates:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {tlrec["durationMinutesOffsetFromStartTime"]}')
        m = re.fullmatch(rePoint, tlrec['point'])
        if not m:
          print(f'ERROR: Timeline point has unexpected format:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {rec["point"]}')
        try:
          float(m[1])
          float(m[2])
        except ValueError:
          print(f'ERROR: Timeline point has unexpected format:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {rec["point"]}')


def extract_timeline(raw):
  """
  Extract the "timelinePath" records from the raw timeline data.
  Returns a new list containing only these records.
  """
  recs = []
  for rec in raw:
    if 'timelinePath' in rec:
      r = {}
      r['startTime'] = rec['startTime']
      r['endTime'] = rec['endTime']
      r['timelinePath'] = []
      for tlrec in rec['timelinePath']:
        tlr = {}
        tlr['point'] = tlrec['point']
        tlr['durationMinutesOffsetFromStartTime'] = \
          tlrec['durationMinutesOffsetFromStartTime']
        r['timelinePath'].append(tlr)
      recs.append(r)
  return recs


def validate_annotated_against_raw(raw, annotated):
  """
  Make sure the existing annotated records still match their corresponding raw
  records.  This validates that the raw records didn't change since they were
  last annotated.  Specifically, it checks that:

  - Each of the annotated records still exists in the raw timeline.
  - The raw records that match the annotated records have the same order in
    both lists.

  Raise an error and exit if these checks fail.
  """
  iraw = 0
  for arec in annotated:
    # Make sure each annotated start / end record exists in the raw timeline.
    astart = arec['startTime']
    aend = arec['endTime']
    while iraw < len(raw) and \
          (raw[iraw]['startTime'] != astart or \
           raw[iraw]['endTime'] != aend):
      iraw += 1
    if iraw >= len(raw):
      print(f'ERROR: Annotated record missing from raw:')
      print(f'       start = {astart}')
      print(f'       end   = {aend}')
      sys.exit(1)

    # Make sure each annotated point in this annotated record exists in the raw
    # timeline.
    rrec = raw[iraw]
    atimeline = arec['timelinePath']
    rtimeline = rrec['timelinePath']
    irpoint = 0
    for atlrec in atimeline:
      apoint = atlrec['point']
      aoff = atlrec['durationMinutesOffsetFromStartTime']
      while irpoint < len(rtimeline) and \
            (rtimeline[irpoint]['point'] != apoint or \
             rtimeline[irpoint]['durationMinutesOffsetFromStartTime'] != aoff):
        irpoint += 1
      if irpoint >= len(rtimeline):
        print(f'ERROR: Annotated point missing from raw:')
        print(f'       start  = {astart}')
        print(f'       offset = {aoff}')
        print(f'       point  = {apoint}')
        sys.exit(1)


def add_annotated_to_cache(annotated, cache):
  """
  Add entries from "annotated" to "cache" for geolocations points that have
  already been mapped to a state.  The cache can be used later to avoid
  geocoder lookups for points that we have previously mapped.  We only add an
  entry to the cache if is was created with the same geocoder service as this
  annotation run.

  The "cache" must be a dictionary.  Each key is a "point" and the value is the
  corresponding state.
  """
  for rec in annotated:
    for tlrec in rec['timelinePath']:
      if tlrec['geocoder'] == args.geocoder:
        point = tlrec['point']
        if not point in cache:
          cache[point] = tlrec['state']


def annotate(raw, annotated, cache):
  """
  Find records from the raw timeline that do not exist in the annotated
  timeline, and annotated them using reverse geocoding to determine the US
  state that contains each coordinate.  Because some reverse geocoding
  services have a daily limit on the number of requests, some raw records
  might not be added to the annotated timeline.  If this happens, an info
  message is printed.

  Returns a new list of annotated records.
  """

  # This will become the list of points from the raw timeline that do not exist
  # in the annotated timeline.
  points = []

  # Loop through the annotated timeline records and match them against their
  # corresponding raw timeline records.  Those records in the raw timeline that
  # do not have a match are newly added and must be annotated.
  #
  # It appears that when a new raw timeline is exported, Google may add new
  # records even for older timestamps.  As a result, we may find new raw
  # records that need to be annotated anywhere in the timeline, not just at the
  # end.
  #
  # The algorithm below assumes that:
  #   - All the annotated timeline records have some match in the raw timeline,
  #   - The order of the annotated records is the same in the raw timeline.
  iraw = 0
  for arec in annotated:
    astart = arec['startTime']
    aend = arec['endTime']

    # If this annotated start/end record does not match the next raw record,
    # then all the points in the raw "timelinePath" are newly added.
    while iraw < len(raw) and \
          (raw[iraw]['startTime'] != astart or \
           raw[iraw]['endTime'] != aend):
      rraw = raw[iraw]
      for rtlrec in rraw['timelinePath']:
        points.append(rtlrec['point'])
      iraw += 1

    # The start/end times of the annotated and raw records match.  Loop through
    # the points in the record's timeline path and compare those.
    rrec = raw[iraw]

    atimeline = arec['timelinePath']
    rtimeline = rrec['timelinePath']
    irpoint = 0
    for atlrec in atimeline:
      apoint = atlrec['point']
      aoff = atlrec['durationMinutesOffsetFromStartTime']

      # If this annotated point does not match the next raw point, the raw
      # point is newly added.
      while irpoint < len(rtimeline) and \
            (rtimeline[irpoint]['point'] != apoint or \
             rtimeline[irpoint]['durationMinutesOffsetFromStartTime'] != aoff):
        rtlrec = rtimeline[irpoint]
        points.append(rtlrec['point'])
        irpoint += 1

      # Advance to the next raw point.
      irpoint += 1

    # We've matched all the annotated points in this record.  If there are
    # still more raw points, they are newly added.
    while irpoint < len(rtimeline):
      rtlrec = rtimeline[irpoint]
      points.append(rtlrec['point'])
      irpoint += 1

    # Advance to the next raw record.
    iraw += 1

  # We've matched all the annotated records.  If there are additional raw
  # records, they are newly added.
  while iraw < len(raw):
    rraw = raw[iraw]
    for rtlrec in rraw['timelinePath']:
      points.append(rtlrec['point'])
    iraw += 1

  if not points:
    print(f'INFO: Nothing to annotate.')
    return annotated

  # If the total number of points to annotated is greater than the command
  # line limit, pare it back.
  total_points = len(points)
  if args.limit and len(points) > args.limit:
    print(f'INFO: Annotating {args.limit} of {len(points)} entries.')
    del points[args.limit:]
  else:
    print(f'INFO: Annotating {len(points)} entries.')

  # Get the corresponding state for each point.  This might return a smaller
  # list if the user interrupts the process or if there is an error.
  states = geocode(points, args.geocoder, cache)
  if len(states) < total_points:
    remaining = total_points - len(states)
    print(f'INFO: There are still {remaining} entries not annotated yet.')

  # It's more efficient to create a new list of annotated records by pushing
  # things onto the end rather than inserting new elements in the middle of
  # the existing list.
  annotated_new = []

  # The loop below pops elements off the "states" list as we add them to the
  # new annotated list.  This is more efficient if we pop the elements off the
  # end, so reverse the list.
  states.reverse()

  # This is basically the same loop over annotated records we did above.  As
  # we find raw records that have no matching annotated record, we pop a state
  # off the "states" list and use that to create a new annotated record.  As we
  # do this, be careful that the "states" list may be shorter than the total
  # number of raw records that need to be annotated.  When the "states" list
  # becomes empty, any remaining unannotated raw records remain unannotated.
  iraw = 0
  for arec in annotated:
    astart = arec['startTime']
    aend = arec['endTime']

    # If this annotated start/end record does not match the next raw record,
    # then all the points in the raw "timelinePath" are newly added.  Create
    # annotated records for each of these points.
    while iraw < len(raw) and \
          (raw[iraw]['startTime'] != astart or \
           raw[iraw]['endTime'] != aend):
      rraw = raw[iraw]
      arec_new = {
        'startTime': rraw['startTime'],
        'endTime': rraw['endTime'],
        'timelinePath': []
      }
      for rtlrec in rraw['timelinePath']:
        if len(states):
          arec_new['timelinePath'].append({
            'durationMinutesOffsetFromStartTime': rtlrec['durationMinutesOffsetFromStartTime'],
            'point': rtlrec['point'],
            'geocoder': args.geocoder,
            'state': states.pop()
          })
      if len(arec_new['timelinePath']):
        annotated_new.append(arec_new)
      iraw += 1

    # The start/end times of the annotated and raw records match.  Loop through
    # the points in the record's timeline path and compare those.
    rrec = raw[iraw]

    atimeline = arec['timelinePath']
    rtimeline = rrec['timelinePath']
    atimeline_new = []
    irpoint = 0
    for atlrec in atimeline:
      apoint = atlrec['point']
      aoff = atlrec['durationMinutesOffsetFromStartTime']

      # If this annotated point does not match the next raw point, the raw
      # point is newly added, so we create an annotated point for it.
      while irpoint < len(rtimeline) and \
            (rtimeline[irpoint]['point'] != apoint or \
             rtimeline[irpoint]['durationMinutesOffsetFromStartTime'] != aoff):
        rtlrec = rtimeline[irpoint]
        if len(states):
          atimeline_new.append({
            'durationMinutesOffsetFromStartTime': rtlrec['durationMinutesOffsetFromStartTime'],
            'point': rtlrec['point'],
            'geocoder': args.geocoder,
            'state': states.pop()
          })
        irpoint += 1

      # This annotated point matches the raw point; add it to the new list of
      # annotated points and advance to the next raw point.
      irpoint += 1
      atimeline_new.append(atlrec)

    # We've matched all the annotated points in this record.  If there are
    # still more raw points, they are newly added.  Add annotated points for
    # them.
    while irpoint < len(rtimeline) and len(states):
      rtlrec = rtimeline[irpoint]
      atimeline_new.append({
        'durationMinutesOffsetFromStartTime': rtlrec['durationMinutesOffsetFromStartTime'],
        'point': rtlrec['point'],
        'geocoder': args.geocoder,
        'state': states.pop()
      })
      irpoint += 1

    # We now have:
    #   - "arec": the annotated start/end record that matches the current raw
    #      record
    #   - "atimeline_new": a new set of annotated points for this record.
    # Add this annotated record to the new annotated list.
    arec_new = {
      'startTime': arec['startTime'],
      'endTime': arec['endTime'],
      'timelinePath': atimeline_new
    }
    annotated_new.append(arec_new)

    # Advance to the next raw record.
    iraw += 1

  # We've matched all the annotated records at this point.  If there are
  # additional start/end records in the raw timeline, they are newly added.
  # Add new annotated records for them.
  while iraw < len(raw) and len(states):
    rraw = raw[iraw]
    arec_new = {
      'startTime': rraw['startTime'],
      'endTime': rraw['endTime'],
      'timelinePath': []
    }
    for rtlrec in rraw['timelinePath']:
      if len(states):
        arec_new['timelinePath'].append({
          'durationMinutesOffsetFromStartTime': rtlrec['durationMinutesOffsetFromStartTime'],
          'point': rtlrec['point'],
          'geocoder': args.geocoder,
          'state': states.pop()
        })
    annotated_new.append(arec_new)
    iraw += 1

  return annotated_new


def geocode(points, geocoder, cache):
  """
  Reverse geocode each "point" to a US state, using the geocoding
  service specified by "geocoder".  Returns a list of strings, where each
  string is a 2-letter US state code (or "EX" if a coordinate is outside of
  the US).  The returned list may have fewer element than "points" if the
  geocoding service is unable to translate all the coordinates.
  """
  if geocoder == 'local': return geocode_local(points)
  if geocoder == 'osm': return geocode_osm(points, cache)
  return []


def geocode_local(points):
  """
  Use the "reverse_geocoder" package to reverse geocode each coordinate to a
  US state.  Since this package runs locally, there is no limit on the number
  of queries, so it reverse geocodes all coordinates.
  """

  # The reverse geocode results includes an "admin1" field which identifies
  # the US state.  This dictionary maps this "admin1" field to a 2-letter state
  # code.
  admin_to_state = {
    'Alabama': 'AL',
    'Alaska': 'AK',
    'Arizona': 'AZ',
    'Arkansas': 'AR',
    'California': 'CA',
    'Colorado': 'CO',
    'Connecticut': 'CT',
    'Delaware': 'DE',
    'Washington, D.C.': 'DC',
    'Florida': 'FL',
    'Georgia': 'GA',
    'Hawaii': 'HI',
    'Idaho': 'ID',
    'Illinois': 'IL',
    'Indiana': 'IN',
    'Iowa': 'IA',
    'Kansas': 'KS',
    'Kentucky': 'KY',
    'Louisiana': 'LA',
    'Maine': 'ME',
    'Maryland': 'MD',
    'Massachusetts': 'MA',
    'Michigan': 'MI',
    'Minnesota': 'MN',
    'Mississippi': 'MS',
    'Missouri': 'MO',
    'Montana': 'MT',
    'Nebraska': 'NE',
    'Nevada': 'NV',
    'New Hampshire': 'NH',
    'New Jersey': 'NJ',
    'New Mexico': 'NM',
    'New York': 'NY',
    'North Carolina': 'NC',
    'North Dakota': 'ND',
    'Ohio': 'OH',
    'Oklahoma': 'OK',
    'Oregon': 'OR',
    'Pennsylvania': 'PA',
    'Rhode Island': 'RI',
    'South Carolina': 'SC',
    'South Dakota': 'SD',
    'Tennessee': 'TN',
    'Texas': 'TX',
    'Utah': 'UT',
    'Vermont': 'VT',
    'Virginia': 'VA',
    'Washington': 'WA',
    'West Virginia': 'WV',
    'Wisconsin': 'WI',
    'Wyoming': 'WY'
  }

  coords = []
  for point in points:
    m = re.match(rePoint, point)
    lat = m[1]
    lon = m[2]
    coords.append((float(lat), float(lon)))

  states = []
  results = rg.search(coords, verbose=False)
  for res in results:
    cc = res['cc']
    admin1 = res['admin1']
    if cc != 'US':
      states.append('EX')
    elif admin1 not in admin_to_state:
      print(f'ERROR: Unexpected "admin1" from reverse geocode "{admin1}".')
      sys.exit(1)
    else:
      states.append(admin_to_state[admin1])
  return states


def geocode_osm(points, cache):
  """
  Use the open street map service to reverse geocode each coordinate to a US
  state.
  """

  # We need an email address in order to use the osm geocoder.
  if not args.email:
    print(f'ERROR: Must specify email adress when using "osm" geocoder.')
    sys.exit(1)

  # Loop over all coordinates, reverse geocoding each one.  This may take a
  # long time if there are many coordinates.  Therefore, the strategy for
  # error handling is to print the error message and terminate the loop, but
  # return any data that was successfully geocoded.  This allows the
  # successful data to be stored in the annotated file.
  states = []
  completed = 0
  cache_hits = 0
  have_sent_osm_req = False
  total = len(points)
  print('INFO: You can interrupt by pressing CTRL-C.')
  try:
    for p in points:
      if p in cache:
        # Avoid doing reverse geocache if we've already seen this point.
        states.append(cache[p])
        cache_hits += 1
      else:
        # The osm terms of use require a 1 second delay between requests.
        # https://operations.osmfoundation.org/policies/nominatim/
        if have_sent_osm_req: time.sleep(1)
        print_newline = (completed > 0)
        ret = send_one_osm_req(p, args.email, print_newline)
        have_sent_osm_req = True
        if ret == 'ERROR':
          break
        cache[p] = ret
        states.append(ret)

      # Print progress.  This does not print a newline, so each of these
      # print statements overwrites the prevous one.
      completed += 1
      pct = (completed / total) * 100
      print(f'\rINFO: Completed {completed} annotations ({pct:.0f}%).',
        end='', flush=True)
    else:
      print('')
  except KeyboardInterrupt:
    if completed: print('')
    print('INFO: Interrupted from keyboard.')

  if completed:
    pct = (cache_hits / completed) * 100
    print(f'INFO: Cache avoided {cache_hits} osm requests ({pct:.0f}%)')
  return states


def send_one_osm_req(point, email, print_newline):
  """
  Send a request to the osm geocoder to reverse geocode one "point".
  Returns one of:
    "ERROR": Indicates an errors with the request
    "EX": Indicates the point is outside of any US state
    Otherwise, the two-letter state code for the point
  """

  # The Nominatim service returns a "state" field which identifies the US
  # state or territory.  This dictionary translates that field into a 2-letter
  # state code, except for territories which are translated to "EX".
  translate_state = {
    'Alabama': 'AL',
    'Alaska': 'AK',
    'Arizona': 'AZ',
    'Arkansas': 'AR',
    'California': 'CA',
    'Colorado': 'CO',
    'Connecticut': 'CT',
    'Delaware': 'DE',
    'District of Columbia': 'DC',
    'Florida': 'FL',
    'Georgia': 'GA',
    'Guam': 'EX',
    'Hawaii': 'HI',
    'Idaho': 'ID',
    'Illinois': 'IL',
    'Indiana': 'IN',
    'Iowa': 'IA',
    'Kansas': 'KS',
    'Kentucky': 'KY',
    'Louisiana': 'LA',
    'Maine': 'ME',
    'Maryland': 'MD',
    'Massachusetts': 'MA',
    'Michigan': 'MI',
    'Minnesota': 'MN',
    'Mississippi': 'MS',
    'Missouri': 'MO',
    'Montana': 'MT',
    'Nebraska': 'NE',
    'Nevada': 'NV',
    'New Hampshire': 'NH',
    'New Jersey': 'NJ',
    'New Mexico': 'NM',
    'New York': 'NY',
    'North Carolina': 'NC',
    'North Dakota': 'ND',
    'Northern Mariana Islands': 'EX',
    'Ohio': 'OH',
    'Oklahoma': 'OK',
    'Oregon': 'OR',
    'Pennsylvania': 'PA',
    'Puerto Rico': 'EX',
    'Rhode Island': 'RI',
    'South Carolina': 'SC',
    'South Dakota': 'SD',
    'Tennessee': 'TN',
    'Texas': 'TX',
    'Utah': 'UT',
    'Vermont': 'VT',
    'Virginia': 'VA',
    'United States Virgin Islands': 'EX',
    'Washington': 'WA',
    'West Virginia': 'WV',
    'Wisconsin': 'WI',
    'Wyoming': 'WY'
  }

  # A coordinate is reverse mapped by sending a REST request to the
  # openstreetmap server.  The "zoom" argument says that we only care about
  # state-level granularity.  The "email" argument is required by their usage
  # policy.
  url = 'https://nominatim.openstreetmap.org/reverse'
  req_args = {
    'format': 'json',
    'zoom': 5,
    'email': email
  }

  # Add the coordinates to the argument list and send the request.
  m = re.match(rePoint, point)
  req_args['lat'] = m[1]
  req_args['lon'] = m[2]
  try:
    r = requests.get(url, params=req_args)
  except Exception as e:
    if print_newline: print('')
    print(f'ERROR: HTTP request error: {str(e)}.')
    return 'ERROR'

  # If we get an error code or the response isn't JSON format,
  # something is wrong.
  if r.status_code != requests.codes.ok:
    if print_newline: print('')
    print(f'ERROR: Response error: {r.status_code}.')
    return 'ERROR'
  try:
    rjson = r.json()
  except ValueError:
    if print_newline: print('')
    print(f'ERROR: Response not JSON.')
    return 'ERROR'

  # If a coordinate is outside of any country (e.g. in the middle of the
  # ocean), the server seems to return an "error" field and omit the
  # "address" field.  Therefore, treat this condition as a location that
  # is outside of any US state.
  #
  # Locations in US territories set the country code to "us", but only
  # some territories return the name of the territory in the "state"
  # field.  Other territories simply omit the "state" field entirely.
  # Therefore, if the "state" field is missing, just treat this as a
  # location that is outside of any US state.
  if 'error' in rjson or 'address' not in rjson or \
      rjson['address'].get('country_code') != 'us' or \
      'state' not in rjson['address']:
    return 'EX'

  # The "translate_state" dictionary contains all the values we expect
  # to see in the "state" field.  If we see any other value, diagnose an
  # error, so the dictionary can be updated.
  rstate = rjson['address']['state']
  if rstate not in translate_state:
    if print_newline: print('')
    print(f'ERROR: Unexpected "state" from reverse geocode "{rstate}".')
    return 'ERROR'
  return translate_state[rstate]


if __name__=="__main__":
  main()

import argparse
import dateutil.parser
import datetime
import requests
import reverse_geocoder as rg
import re
import sys
import time
import util

args = None

# Regular expression to match a coordinate point in the timeline.
# The latitude and longitude are each expressed as a decimal floating point
# number.
rePoint = re.compile('geo:(-?\d*\.\d*),(-?\d*\.\d*)')

def main():
  # Parse command line arguments and read input files.
  parse_args()
  raw = util.read_json_file(args.raw)
  annotated = util.read_json_file(args.annotated, default=[])

  # The raw timeline data is a JSON file that is generated by Google, and they
  # may decide to change its format.  This and the other scripts make certain
  # assumptions about the format of the raw data, so check to make sure those
  # assumptions are true.
  validate_raw(raw)

  # The raw timeline data is a list of different types of records.  We only
  # care about the records that have "timelinePath".  Extract these records
  # into a new list.
  raw_timeline = extract_timeline(raw)

  # Compare the previously annotated records with the raw records to make
  # sure they didn't change.  Raise an error and quit if the validation fails.
  validate_annotated_against_raw(raw_timeline, annotated)

  # Reverse geocoding the coordinates can be expensive, so we want to avoid
  # duplicate geocode operations.  Create a cache of the existing annotated
  # data that maps each coordinate to its state.  We can use this cache later
  # in case a new raw record happens to have the same coordinates as one we
  # have already reverse geocoded.
  cache = make_geocode_cache(annotated)

  # Create annotated records for the new raw records, then write out the
  # annotated data.
  annotate(raw_timeline, annotated, cache)
  util.write_json_file(annotated, args.annotated)


def parse_args():
  """Parse the command line arguments into global "args"."""
  global args
  parser = argparse.ArgumentParser(
      description='Create or update annotated geolocation file from Google '
        'timeline.')
  parser.add_argument('-r', '--raw', required=True,
      help='Raw Google timeline input JSON file.')
  parser.add_argument('-a', '--annotated', required=True,
      help='Annotated output JSON file.')
  parser.add_argument('--geocoder', choices=['local', 'osm'],
      help='Reverse geocoding service to use, only if annotated file does '
        'not yet exist.')
  parser.add_argument('--email',
      help='Your email address. Required when using "osm" geocoder.')
  parser.add_argument('--limit', type=int,
      help='Limit reverse geocoding to to this many requests.')
  args = parser.parse_args()


def validate_raw(raw):
  """
  Validate our assumptions about the format of the raw timeline data.  Raise
  an error and exit if any of the checks fail.
  """
  if not isinstance(raw, list):
    print(f'ERROR: Raw timeline not a list.')
    sys.exit(1)

  lastEndTime = None
  for rec in raw:
    if not isinstance(rec, dict):
      print(f'ERROR: Raw timeline record not a dictionary.')
      sys.exit(1)

    if 'startTime' not in rec or 'endTime' not in rec:
      print(f'ERROR: Raw timeline record missing start or end time.')
      sys.exit(1)

    try :
      start = dateutil.parser.isoparse(rec['startTime'])
      end = dateutil.parser.isoparse(rec['endTime'])
    except Exception:
      print(f'ERROR: Start or end time has unexpected format:')
      print(f'       Start: {rec["startTime"]}')
      print(f'       End:   {rec["endTime"]}')
      sys.exit(1)

    # The start and end times must be "aware" (containing timezone
    # information), not "naive" (without timezone information).
    if start.tzinfo == None or end.tzinfo == None or \
       start.tzinfo.utcoffset(start) == None or \
       end.tzinfo.utcoffset(end) == None:
      print(f'ERROR: Start or end time is naive (missing timzone):')
      print(f'       Start: {rec["startTime"]}')
      print(f'       End:   {rec["endTime"]}')
      sys.exit(1)

    if start >= end:
      print(f'ERROR: Start time not less than end time:')
      print(f'       Start: {rec["startTime"]}')
      print(f'       End:   {rec["endTime"]}')
      sys.exit(1)

    if 'timelinePath' in rec:
      # The "timelinePath" records must be sorted in time and must not
      # overlap with any other "timelinePath" record.  Note that the
      # non-timelinePath records *do* overlap and are not sorted, but
      # the scripts don't care about this.
      if lastEndTime and start < lastEndTime:
        print(f'ERROR: Start time less than last end time:')
        print(f'       Start: {rec["startTime"]}')
        sys.exit(1)
      lastEndTime = end

      tlPath = rec['timelinePath']
      if not isinstance(tlPath, list):
        print(f'ERROR: Timeline path not a list:')
        print(f'       Start: {rec["startTime"]}')
        sys.exit(1)

      for tlrec in tlPath:
        if not isinstance(tlrec, dict):
          print(f'ERROR: Timeline path record not a dictionary:')
          print(f'       Start: {rec["startTime"]}')
          sys.exit(1)

        try:
          offset = int(tlrec['durationMinutesOffsetFromStartTime'])
        except Exception:
          print(f'ERROR: Timeline path record missing offset or not an int:')
          print(f'       Start: {rec["startTime"]}')

        # Each record in the timeline path contains an offset (in minutes) from
        # the start time.  This offset must be within the [start, end] range.
        #
        # Note that the range includes both start and end.  As a result, a
        # point at the very end of one range and a point as the very beginning
        # of the next range have the same timestamp.
        pointTime = start + datetime.timedelta(minutes=offset)
        if pointTime > end:
          print(f'ERROR: Timeline point time after end time:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {tlrec["durationMinutesOffsetFromStartTime"]}')
          sys.exit(1)

        if 'point' not in tlrec:
          print(f'ERROR: Timeline path record missing coordinates:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {tlrec["durationMinutesOffsetFromStartTime"]}')
        m = re.fullmatch(rePoint, tlrec['point'])
        if not m:
          print(f'ERROR: Timeline point has unexpected format:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {rec["point"]}')
        try:
          float(m[1])
          float(m[2])
        except ValueError:
          print(f'ERROR: Timeline point has unexpected format:')
          print(f'       Start: {rec["startTime"]}')
          print(f'       End:   {rec["endTime"]}')
          print(f'       Point: {rec["point"]}')


def extract_timeline(raw):
  """
  Extract the "timelinePath" records from the raw timeline data.
  Returns a new list containing only these records.
  """
  recs = []
  for rec in raw:
    if 'timelinePath' in rec:
      r = {}
      r['startTime'] = rec['startTime']
      r['endTime'] = rec['endTime']
      r['timelinePath'] = []
      for tlrec in rec['timelinePath']:
        tlr = {}
        tlr['point'] = tlrec['point']
        tlr['durationMinutesOffsetFromStartTime'] = \
          tlrec['durationMinutesOffsetFromStartTime']
        r['timelinePath'].append(tlr)
      recs.append(r)
  return recs


def validate_annotated_against_raw(raw, annotated):
  """
  Make sure the existing annotated records still match their corresponding raw
  records.  This validates that the raw records didn't change since they were
  last annotated.
  """
  irec = 0
  for rrec, arec in zip(raw, annotated):
    # Make sure the start and end times didn't change.
    if rrec['startTime'] != arec['startTime']:
      print(f'ERROR: Annotated start time mismatch: {arec["startTime"]}')
      sys.exit(1)
    if rrec['endTime'] != arec['endTime']:
      print(f'ERROR: Annotated end time mismatch: {arec["endTime"]}')
      sys.exit(1)

    # The number of "points" in each record should not change.  However,
    # new "points" may have been added to the last raw record since it was
    # last annotated, so the last annotated record may have fewer points than
    # its associatd raw record.
    if irec < len(annotated)-1:
      mismatch = (len(rrec['timelinePath']) != len(arec['timelinePath']))
    else:
      mismatch = (len(rrec['timelinePath']) < len(arec['timelinePath']))
    if mismatch:
      print(f"ERROR: Annotated timeline count mismatch:")
      print(f'       Start time: {arec["startTime"]}')
      sys.exit(1)

    # Make sure each "point" did not change.
    for rtlrec, atlrec in zip(rrec['timelinePath'], arec['timelinePath']):
      if rtlrec['point'] != atlrec['point']:
        print(f'ERROR: Annotated point mismatch: {atlrec["point"]}')
        print(f'       Start time: {arec["startTime"]}')
        sys.exit(1)
      if rtlrec['durationMinutesOffsetFromStartTime'] != atlrec['durationMinutesOffsetFromStartTime']:
        print(f'ERROR: Annotated offset mismatch: {atlrec["durationMinutesOffsetFromStartTime"]}')
        print(f'       Start time: {arec["startTime"]}')
        sys.exit(1)
    irec += 1


def make_geocode_cache(annotated):
  """
  Return a dictionary mapping "point" to its associated "state" from the
  existing annotated records.  We only add entries in this dictionary when
  the "state" was created with the same geocoder as this annotation run.
  The dictionary can be used to avoid redundant geocoder lookups for points
  we have seen before.
  """
  cache = {}
  for rec in annotated:
    for tlrec in rec['timelinePath']:
      if tlrec['geocoder'] == args.geocoder:
        point = tlrec['point']
        if not point in cache:
          cache[point] = tlrec['state']
  return cache


def annotate(raw, annotated, cache):
  """
  Add records from the raw timeline to the annotated timeline, using reverse
  geocoding to determine the US state that contains each coordinate.  Because
  some reverse geocoding services have a daily limit on the number of requests,
  some raw records might not be added to the annotated timeline.  If this
  happens, an info message is printed.
  """

  # Get the index of the first record to annotate.  This is the first raw
  # record that does not have a corresponding annotated record.
  if not len(annotated):
    irec_first = 0
    itlrec_first = 0
  else:
    irec_first = len(annotated)-1
    itlrec_first = len(annotated[irec_first]['timelinePath'])
    if itlrec_first >= len(raw[irec_first]['timelinePath']):
      irec_first += 1
      itlrec_first = 0

  # Create a list of all the "points" that need to be annotated.
  points = []
  irec = irec_first
  itlrec = itlrec_first
  while irec < len(raw):
    rec = raw[irec]
    tlrec = rec['timelinePath'][itlrec]
    points.append(tlrec['point'])
    itlrec += 1
    if itlrec >= len(rec['timelinePath']):
      irec += 1
      itlrec = 0

  if not points:
    print(f'INFO: Nothing to annotate.')
    return

  total_points = len(points)
  if args.limit and len(points) > args.limit:
    print(f'INFO: Annotating {args.limit} of {len(points)} entries.')
    del points[args.limit:]
  else:
    print(f'INFO: Annotating {len(points)} entries.')

  # Get the corresponding state for each point.  This might return a smaller
  # list if the user interrupts the process or if there is an error.
  states = geocode(points, args.geocoder, cache)
  if len(states) < total_points:
    remaining = total_points - len(states)
    print(f'INFO: There are still {remaining} entries not annotated yet.')

  # Create a new annotated record for each point that we reverse geocoded.
  irec = irec_first
  itlrec = itlrec_first
  for state in states:
    rrec = raw[irec]
    rtlrec = rrec['timelinePath'][itlrec]
    if irec < len(annotated):
      arec = annotated[irec]
    else:
      arec = {
        'endTime': rrec['endTime'],
        'startTime': rrec['startTime'],
        'timelinePath': []
        }
      annotated.append(arec)
    atlrec = {
      'point': rtlrec['point'],
      'durationMinutesOffsetFromStartTime': rtlrec['durationMinutesOffsetFromStartTime'],
      'geocoder': args.geocoder,
      'state': state
      }
    arec['timelinePath'].append(atlrec)
    itlrec += 1
    if itlrec >= len(rrec['timelinePath']):
      irec += 1
      itlrec = 0


def geocode(points, geocoder, cache):
  """
  Reverse geocode each "point" to a US state, using the geocoding
  service specified by "geocoder".  Returns a list of strings, where each
  string is a 2-letter US state code (or "EX" if a coordinate is outside of
  the US).  The returned list may have fewer element than "points" if the
  geocoding service is unable to translate all the coordinates.
  """
  if geocoder == 'local': return geocode_local(points)
  if geocoder == 'osm': return geocode_osm(points, cache)
  return []


def geocode_local(points):
  """
  Use the "reverse_geocoder" package to reverse geocode each coordinate to a
  US state.  Since this package runs locally, there is no limit on the number
  of queries, so it reverse geocodes all coordinates.
  """

  # The reverse geocode results includes an "admin1" field which identifies
  # the US state.  This dictionary maps this "admin1" field to a 2-letter state
  # code.
  admin_to_state = {
    'Alabama': 'AL',
    'Alaska': 'AK',
    'Arizona': 'AZ',
    'Arkansas': 'AR',
    'California': 'CA',
    'Colorado': 'CO',
    'Connecticut': 'CT',
    'Delaware': 'DE',
    'Washington, D.C.': 'DC',
    'Florida': 'FL',
    'Georgia': 'GA',
    'Hawaii': 'HI',
    'Idaho': 'ID',
    'Illinois': 'IL',
    'Indiana': 'IN',
    'Iowa': 'IA',
    'Kansas': 'KS',
    'Kentucky': 'KY',
    'Louisiana': 'LA',
    'Maine': 'ME',
    'Maryland': 'MD',
    'Massachusetts': 'MA',
    'Michigan': 'MI',
    'Minnesota': 'MN',
    'Mississippi': 'MS',
    'Missouri': 'MO',
    'Montana': 'MT',
    'Nebraska': 'NE',
    'Nevada': 'NV',
    'New Hampshire': 'NH',
    'New Jersey': 'NJ',
    'New Mexico': 'NM',
    'New York': 'NY',
    'North Carolina': 'NC',
    'North Dakota': 'ND',
    'Ohio': 'OH',
    'Oklahoma': 'OK',
    'Oregon': 'OR',
    'Pennsylvania': 'PA',
    'Rhode Island': 'RI',
    'South Carolina': 'SC',
    'South Dakota': 'SD',
    'Tennessee': 'TN',
    'Texas': 'TX',
    'Utah': 'UT',
    'Vermont': 'VT',
    'Virginia': 'VA',
    'Washington': 'WA',
    'West Virginia': 'WV',
    'Wisconsin': 'WI',
    'Wyoming': 'WY'
  }

  coords = []
  for point in points:
    m = re.match(rePoint, point)
    lat = m[1]
    lon = m[2]
    coords.append((float(lat), float(lon)))

  states = []
  results = rg.search(coords, verbose=False)
  for res in results:
    cc = res['cc']
    admin1 = res['admin1']
    if cc != 'US':
      states.append('EX')
    elif admin1 not in admin_to_state:
      print(f'ERROR: Unexpected "admin1" from reverse geocode "{admin1}".')
      sys.exit(1)
    else:
      states.append(admin_to_state[admin1])
  return states


def geocode_osm(points, cache):
  """
  Use the open street map service to reverse geocode each coordinate to a US
  state.
  """

  # We need an email address in order to use the osm geocoder.
  if not args.email:
    print(f'ERROR: Must specify email adress when using "osm" geocoder.')
    sys.exit(1)

  # Loop over all coordinates, reverse geocoding each one.  This may take a
  # long time if there are many coordinates.  Therefore, the strategy for
  # error handling is to print the error message and terminate the loop, but
  # return any data that was successfully geocoded.  This allows the
  # successful data to be stored in the annotated file.
  states = []
  completed = 0
  cache_hits = 0
  have_sent_osm_req = False
  total = len(points)
  print('INFO: You can interrupt by pressing CTRL-C.')
  try:
    for p in points:
      if p in cache:
        # Avoid doing reverse geocache if we've already seen this point.
        states.append(cache[p])
        cache_hits += 1
      else:
        # The osm terms of use require a 1 second delay between requests.
        # https://operations.osmfoundation.org/policies/nominatim/
        if have_sent_osm_req: time.sleep(1)
        print_newline = (completed > 0)
        ret = send_one_osm_req(p, args.email, print_newline)
        have_sent_osm_req = True
        if ret == 'ERROR':
          break
        cache[p] = ret
        states.append(ret)

      # Print progress.  This does not print a newline, so each of these
      # print statements overwrites the prevous one.
      completed += 1
      pct = (completed / total) * 100
      print(f'\rINFO: Completed {completed} annotations ({pct:.0f}%).',
        end='', flush=True)
    else:
      print('')
  except KeyboardInterrupt:
    if completed: print('')
    print('INFO: Interrupted from keyboard.')

  pct = (cache_hits / completed) * 100
  print(f'INFO: Cache avoided {cache_hits} osm requests ({pct:.0f}%)')
  return states


def send_one_osm_req(point, email, print_newline):
  """
  Send a request to the osm geocoder to reverse geocode one "point".
  Returns one of:
    "ERROR": Indicates an errors with the request
    "EX": Indicates the point is outside of any US state
    Otherwise, the two-letter state code for the point
  """

  # The Nominatim service returns a "state" field which identifies the US
  # state or territory.  This dictionary translates that field into a 2-letter
  # state code, except for territories which are translated to "EX".
  translate_state = {
    'Alabama': 'AL',
    'Alaska': 'AK',
    'Arizona': 'AZ',
    'Arkansas': 'AR',
    'California': 'CA',
    'Colorado': 'CO',
    'Connecticut': 'CT',
    'Delaware': 'DE',
    'District of Columbia': 'DC',
    'Florida': 'FL',
    'Georgia': 'GA',
    'Guam': 'EX',
    'Hawaii': 'HI',
    'Idaho': 'ID',
    'Illinois': 'IL',
    'Indiana': 'IN',
    'Iowa': 'IA',
    'Kansas': 'KS',
    'Kentucky': 'KY',
    'Louisiana': 'LA',
    'Maine': 'ME',
    'Maryland': 'MD',
    'Massachusetts': 'MA',
    'Michigan': 'MI',
    'Minnesota': 'MN',
    'Mississippi': 'MS',
    'Missouri': 'MO',
    'Montana': 'MT',
    'Nebraska': 'NE',
    'Nevada': 'NV',
    'New Hampshire': 'NH',
    'New Jersey': 'NJ',
    'New Mexico': 'NM',
    'New York': 'NY',
    'North Carolina': 'NC',
    'North Dakota': 'ND',
    'Northern Mariana Islands': 'EX',
    'Ohio': 'OH',
    'Oklahoma': 'OK',
    'Oregon': 'OR',
    'Pennsylvania': 'PA',
    'Puerto Rico': 'EX',
    'Rhode Island': 'RI',
    'South Carolina': 'SC',
    'South Dakota': 'SD',
    'Tennessee': 'TN',
    'Texas': 'TX',
    'Utah': 'UT',
    'Vermont': 'VT',
    'Virginia': 'VA',
    'United States Virgin Islands': 'EX',
    'Washington': 'WA',
    'West Virginia': 'WV',
    'Wisconsin': 'WI',
    'Wyoming': 'WY'
  }

  # A coordinate is reverse mapped by sending a REST request to the
  # openstreetmap server.  The "zoom" argument says that we only care about
  # state-level granularity.  The "email" argument is required by their usage
  # policy.
  url = 'https://nominatim.openstreetmap.org/reverse'
  req_args = {
    'format': 'json',
    'zoom': 5,
    'email': email
  }

  # Add the coordinates to the argument list and send the request.
  m = re.match(rePoint, point)
  req_args['lat'] = m[1]
  req_args['lon'] = m[2]
  try:
    r = requests.get(url, params=req_args)
  except Exception as e:
    if print_newline: print('')
    print(f'ERROR: HTTP request error: {str(e)}.')
    return 'ERROR'

  # If we get an error code or the response isn't JSON format,
  # something is wrong.
  if r.status_code != requests.codes.ok:
    if print_newline: print('')
    print(f'ERROR: Response error: {r.status_code}.')
    return 'ERROR'
  try:
    rjson = r.json()
  except ValueError:
    if print_newline: print('')
    print(f'ERROR: Response not JSON.')
    return 'ERROR'

  # If a coordinate is outside of any country (e.g. in the middle of the
  # ocean), the server seems to return an "error" field and omit the
  # "address" field.  Therefore, treat this condition as a location that
  # is outside of any US state.
  #
  # Locations in US territories set the country code to "us", but only
  # some territories return the name of the territory in the "state"
  # field.  Other territories simply omit the "state" field entirely.
  # Therefore, if the "state" field is missing, just treat this as a
  # location that is outside of any US state.
  if 'error' in rjson or 'address' not in rjson or \
      rjson['address'].get('country_code') != 'us' or \
      'state' not in rjson['address']:
    return 'EX'

  # The "translate_state" dictionary contains all the values we expect
  # to see in the "state" field.  If we see any other value, diagnose an
  # error, so the dictionary can be updated.
  rstate = rjson['address']['state']
  if rstate not in translate_state:
    if print_newline: print('')
    print(f'ERROR: Unexpected "state" from reverse geocode "{rstate}".')
    return 'ERROR'
  return translate_state[rstate]


if __name__=="__main__":
  main()
